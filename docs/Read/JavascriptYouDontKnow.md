---
title: 你不知道的 JavaScript
---

# <font color="#00C0FD">你不知道的 JavaScript</font> 

### LHS 查询，RHS 查询  
> LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）”。

```js
    function foo(a) {
        let b = a
        return b + a
    }
    let c = foo(2)
```

LHS查询：  
1. c = ...
2. a = 2
3. b = ... 

RHS查询：
1. foo(...
2. ... = a
3. a...
4. b...

> 变量在左侧，赋值操作，LHS；变量在右侧，引用操作，RHS；仅引用操作，RHS。  

### 在代码中不要使用 eval()，with()  
> “欺骗”词法作用域：eval(..)和with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。  

### 提升  
> 函数声明和变量声明都会被提升。但是一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。

> 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制（示例如下），因此应该尽可能避免在块内部声明函数。
```js
foo(); // 'b'

var a = true
if(a) {
    function foo() {
        console.log('a')
    }
} else {
    function foo() {
        console.log('b')
    }
}
```
### 闭包  
> 本质上无论何时何地，如果将（访问它们各自词法作用域的）函数当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！ 

### 词法作用域和动态作用域  
> 主要区别：词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。（this也是！）词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。  

> 事实上JavaScript并不具有动态作用域。它只有词法作用域，简单明了。但是this机制某种程度上很像动态作用域。  
```js
function cut() {
    console.log(a) // 词法作用域：3；动态作用域：2
}

function bar() {
    let a = 2
    cut()
}

let a = 3 
bar()
```  
### 判断this的绑定对象  
1. 由`new`调用？绑定到新创建的对象。
2. 由`call`或者`apply`（或者`bind`）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到`undefined`，否则绑定到全局对象。  

> 一定要注意，有些调用可能在无意中使用默认绑定规则。如果想“更安全”地忽略this绑定，你可以使用一个DMZ对象，比如ø = Object.create(null)，以保护全局对象。  

> ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this绑定（无论this绑定到什么）。这其实和ES6之前代码中的self = this机制一样。