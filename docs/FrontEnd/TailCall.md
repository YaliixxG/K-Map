---
title: 尾调用和尾递归
---

# <font color="#228B22">尾调用和尾递归</font>

### 尾调用 

#### 什么是尾调用？  

指某个函数的最后一步是调用另一个函数。

```js
function f(x) {
    return l(x) // f(x)函数的最后一步是调用l(x)函数
}  
```  
但是最后一步除了调用函数，还做了其它操作，或者是等价操作都是不属于尾调用，例如：  

```js
function f(x) {
    g = l(x)
    return g // 虽然是等价的，但是不属于尾调用
}  

function f(x) {
    return l(x) + 2 // 除了调用函数，还做了其它操作，即使是在同一行，但是不属于尾调用
}
```  
尾调用不一定要出现在函数的尾部，只要是最后一步调用即可。  

```js
function f(x) {
    if (x > 0) {
        return l(x) // 出现在代码块的最后一步执行调用l(x)函数，属于尾调用
    }
    return m(x) // m(x)与l(x)都属于尾调用
}  
```  

#### 尾调用优化  

尾调用存在的意义就在于它的执行位置。  

函数调用时，会在内部形成一个调用记录，叫做[调用帧](http://blog.yaliixxg.top/FrontEnd/callStack.html)。倘若A函数内部调用了B函数，则先生成的是A函数的调用记录，然后再在A函数的上方形成B函数的调用记录，直到B函数运行结束，将结果返回给A函数后，B函数的调用记录才会消失。如果B函数内部还调用C函数，则C函数的调用记录会在B函数的上方，直到C函数运行结束，将结果返回给B函数，C函数的调用记录才会消失。以此类推，所有的调用记录就形成了一个[调用栈](http://blog.yaliixxg.top/FrontEnd/callStack.html)  

<font color="#00CED1">*尾调用由于是函数的最后一步执行，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息不会再用到了，所以可以直接由内层函数的调用记录来取代外层的调用记录*  </font>

```js
function f(x) {
    let a = 1;
    let b = 2;
    return g(a + b) 
f()  

// 等同于  
function f(x) {
    return g(3) 
}
f()  

// 等同于  
g(3) 
```  
上述函数中，如果函数g不是尾调用，则函数f需要保存变量a、b的值，以及g的调用位置，但由于函数g是尾调用，所以当函数g调用之后，函数f就结束了，所以执行到最后一步，完全可以删除函数f的调用记录，只保留g(3)的调用记录。  

<font color="#00CED1">*这就是尾调用优化，即只保留内层函数的调用记录  
如果所有函数都是尾调用，则每次执行完，调用记录只有一项，可以大大的节省的内存*</font>  

### 尾递归  

#### 什么是尾递归？  

函数调用自身，叫做递归；而尾调用自身，则叫尾递归。  

递归本身是非常消耗内存，因为需要同时保存成千上百个调用记录，很容易发生栈溢出错误。  
但对于尾递归来说，由于只存在一个调用记录，所以永远不会发生栈溢出错误。  

例如以下递归：  

```js
function t(n) {
    if(n === 1) return 1;
    return n * t(n - 1)
}  

t(5) // 120  复杂度O(n)
```   
上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。  

如果改写成尾递归,只保留一个调用记录，复杂度 O(1) ：  

```js  
function t(n, total) {
    if(n === 1) return total;
    return t(n - 1, n * total)
}

t(5, 1) // 120 复杂度O(1)  

// 运算过程如下  
// t(5, 1)  
// t(4, 5 * 1)  
// t(3, 4 * 5 * 1)
// t(2, 3 * 4 * 5 * 1)  
// t(1, 2 * 3 * 4 * 5 * 1) // 此时 total = 120  
// 当 n === 1 时，返回 total, 120
```    
这里是利用了一个中间值`total`，用来计算每一步的结果，然后当做参数传入，这就可以形成尾递归  

#### 递归函数改写尾递归    

尾递归的实现，需要改写递归函数，确保最后一步只调用自身。   

方法： 将所有用到的内部变量改写成函数的参数，例如上面的例子total，则是把它作为函数的参数。  

如果不太直观也可以这么写：  

```js
function t(n, total) {
    if (n === 1) return total;
    return t(n - 1, n * total)
}

// 写一个中间函数，如何获得的这个中间值 total
function f(n) {
    return t(n, 1)
}

f(5) // 120
``` 

也可以用ES6的写法：
```js
function t(n, total = 1) {
    if(n === 1) return total;
    return t(n - 1, n * total)
}
```
