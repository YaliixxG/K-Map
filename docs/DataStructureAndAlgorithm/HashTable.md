---
title: 哈希表（散列表）
--- 

# <font color="#32CD32">哈希表（散列表）</font>   

#### 怎么理解哈希表？  

哈希表其实很多语言都已经内置实现了，例如`python`中的`dict()`字典就是哈希表。  
在`js`中比较类似的是`object`对象。  
就是可以通过键值对这种形式直接访问的数据结构。  

如果一家面包店，有各种面包名字，当顾客来问服务员Lucy，某种面包价格时：  
* 简单查找：Lucy会拿出一张记录了所有面包种类，以及价格的表，从第一个开始去查找。 时间复杂度为线性复杂度`O(n)`  
* 二分查找：Lucy会拿出一张记录了所有面包种类，以及价格的表，但是这个表是有序的，按照字母的顺序来记录的。所以查找起来比简单查找要快的多 时间复杂度为对数复杂度`O(logn)` 
* 哈希表：Lucy在脑海里一想直接张口就说出了价格。时间复杂度为常数复杂度`O(1)`  

哈希表就像数组一样，无论你获取第一个元素，还是你获取第十万个元素，复杂度都为`O(1)`，时间是一样的。  

#### 哈希函数（散列函数）  

哈希函数就是无论你给的是什么数据，都会返回给你一个数字。 （将输入映射到数字）  
虽然你单独看哈希函数返回的数字没有什么规律，但是它一定满足下列规律：  

* 每次你输入同一个数据时，返回的数字一定是一样的。也就是你输入“年轮面包”，返回给你14，你再一次输入“年轮面包”，返回给你的还是14  
* 不同的输入映射应当返回的是不同的数字。如果你输入不同的数字都返回给你数字1，那这个哈希函数是有问题的。  

```js
{
    "milk": 3.5, // 牛奶对应3.5元
    "sugar": 2.5, // 糖对应2.5元
    "water": 2 // 水对应2元
}
```    

#### 冲突  

当你的内存有五个格子给你放5个键值，但是你却有10个键值需要存放，此时就会出现冲突，最理想的情况每个格子也要存放两个键值。  
第一个格子先存了牛奶，结果苹果也要存在这个位置，就会导致覆盖掉牛奶的数据了。
此时可以在第一个位置存放一个链表，牛奶和苹果都存放在这个位置，查询时，可以通过查找这个位置的链表来进行查询。  

理想的`哈希函数`： 
* 可以将键均匀的映射到哈希表的不同位置，不让值扎堆，导致大量冲突    
* 哈希表存储的链表不应该很长，如果很长，哈希表的查找速度也会急剧下降。


#### 哈希表的应用  
* 查找  
    用于查找，速度非常快，只需输入你想查找的键值，则会返回给你与输入映射的值。 
    我们平常的上网，例如网址`www.baidu.com`，它都会被转为一个唯一的IP地址，然后再进行访问。（DNS解析）   
* 防止重复  
    嗯... 这个就是你通过建立一个哈希表，来快速知道，你输入的这个键值是否映射的数据  
* 缓存  
    平常我们浏览网页，如果是我们经常浏览的，很有可能访问的就是缓存的数据。这样可以速度更快的处理响应，返回给你这个网页。  
    就像问一个小学生，6*7等于多少？他前几次可能需要查九九乘法表来找到答案，但是当他查询次数多了以后就记住了这个值，你再次问的时候，他能快速回答42。  
    就像百度，很多用户高频率访问的网页会缓存下来，当用户输入这个网址时，就不必请求服务器，再让服务器返回一个网页内容给你了。而是直接在缓存中拿出来展示给你。  
    *缓存是一种常用的加速方式，所有大型网站都是用缓存，而缓存的数据则存储在哈希表中*   

#### 填装因子  

填装因子的计算：哈希表包含的元素个数 / 哈希表位置总数  
哈希表是用数组来实现的，如果创建一个长度10的数组，但是只放入了5个元素，则填装因子为0.5  
填装因子越低，哈希表性能越好
所以一般当填装因子超过`0.7`时，需要扩充数组的长度    

#### 总结  

* 可以用数组和哈希函数创建哈希表  
* 哈希函数一定要最大限度的减少冲突  
* 哈希表的查找，删除，插入的速度都非常快  
* 哈希表可以模拟映射  
* 当填装因子超过`0.7`时，需要扩充数组的长度
* 哈希表可以用来缓存数据  
* 非常适合防止重复




