---
title: 链表
--- 

# <font color="#32CD32">链表</font>

### 237. 根据val来删除链表  

思路：要考虑删除的是 `head` 的情况，以及将 `prev` 的概念切换成 `current` 和 `current.next`

### 剑指offer22. 删除倒数第N个节点  

思路：利用双指针来进行，两个指针（first, second）。`first`指针与second指针的相差的节点数就是N，这样当first指针到null时，此时`second`的指针的下一个节点即是要删除的节点。如果仅在操作first指针时就已经到null了，则证明是要删除的节点为头节点（head）,所以返回`head.next`。 

### 876. 找出链表中间点

思路：利用快慢双指针，慢指针每走一步，快指针走两步。  
* 当链表节点为奇数时，判断条件为 `fast.next!== null` 
* 当链表节点为偶数时，判断条件为 `fast!== null` 

### 206. 反转链表

思路：需要三个指针，一个当前指针 `curr`，一个指向下一个的指针 `next`，一个 `curr`前面的指针 prev。本质上我们是要让链表的指向反过来，则形成了反转链表，所以我们需要把 `curr.next = prev`。但是 `curr`需要继续往下走，所以 `next` 相当于用来存储 `curr` 的下一次位置。 

### 92. 从中间规定首位位置反转链表   1->2->3->4->5，给出位置 2，4，则：1->4->3->2->5

思路：根据首尾位置，将其进行局部反转，在进行链表拼接。拼接时会出现指向的问题，所以在反转前存住两个位置，即上面`1`与`2`的位置，反转拼接后，再通过指向的改变完成。

### 234. 判断是否为回文链表 1->2->2->1  

思路：  
1. 找出中间点，将链表分二
2. 将后半段的链表反转  
3. 将反转后的链表与原链表进行值的比较，若不同则 `false`，否则继续比较直至完成，为 `true`

### 141. 环形链表  

判断链表是否有环 

思路：利用快慢双指针，慢指针每走一步，快指针走两步。如果有环，两指针一定会相遇。

### 61. 旋转链表
> 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。输入：head = [1,2,3,4,5], k = 2
输出：[4,5,1,2,3]  

思路：  
1. 需要连接链表  
2. 找出步数规律，断开链表
3. 步数的规律最为关键

### 1669.合并两个链表  
> 给你两个链表 list1 和 list2 ，它们包含的元素分别为 n 个和 m 个。请你将 list1 中第 a 个节点到第 b 个节点删除，并将list2 接在被删除节点的位置。  

思路：一定要看清楚，a 和 b 为位置，而不是 val  
1. 将 a 的前一个位置占位A，将 b 的后一个位置进行占位B  
2. 占位后，让 `A.next = list2`
3. 遍历list2，让 `list2的尾结点的 next = B`    
4. 返回头节点时，记得在最开始的时候，将 list1 保存，此时在最后再返回即可  

### 剑指 Offer 52. 两个链表的第一个公共节点  
> 输入两个链表，找出它们的第一个公共节点。  输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。  

思路一：   
1. 遍历节点，得出两个链表长度的差值  
2. 由长度差，可以将较长的链表位置定于和短链表起始位置一致处  
3. 再同时遍历两链表，若节点相同，则抛出节点，否则继续遍历，直至遍历完，若一致无相同节点则抛出 null  

思路二：  
1. 使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点
2. 同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；
3. 当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。
4. 当它们相遇时，所指向的结点就是第一个公共结点。



